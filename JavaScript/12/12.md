# 继承发展史

- 传统形式 : 原型链 ( 过多地继承了没用的属性 )

- 使用 call/apply 来借用别的方法实现自己的功能 ( 不能继承借用的构造函数的原型 )

- 共享原型 ( 无法实现原型A既继承原型B的属性又同时拥有自己的独有属性 )

  ```
  function Father() {}
  function Son() {}

  function inherit(Target, Origin) {
    Target.prototype = Origin.prototype;
  }

  inherit(Son, Father);
  ```

- **圣杯模式**

  ![](./angleCup.png)

  - 通俗写法

    ```
    function inherit(Target, Origin) {
      var F = function () {}
      F.prototype = Origin.prototype;
      Target.prototype = new F();
      Target.prototype.constructor = Target;
      Target.prototype.uber = Origin.prototype;
    }
    ```

  - 结合闭包 , 将中间函数F私有化

    ```
    var inherit = (function () {
      var F = function () {}
      return function(Target, Origin) {
        F.prototype = Origin.prototype;
        Target.prototype = new F();
        Target.prototype.constructor = Target;
        Target.prototype.uber = Origin.prototype;
      }
    }())
    ```

-----------------------------------------------------

## 多人协作模块化开发、防止污染全局变量的方法

- 老方法 : 命名空间

  ```
  var org = {
    department1: {
      xiaoming: {
        name: 'xiaoming',
        age: 20
      },
      xiaohong: {
        name: 'xiaohong',
        age: 18
      }
    },
    department2: {
      xiaowang: {
        name: 'xiaowang',
        age: 21
      },
      xaioli: {
        name: 'xaioli',
        age: 22
      }
    }
  }
  ```
  ```
  // 四人协作获取各自的命名空间如下
  var xiaoming = org.department1.xiaoming;
  var xiaohong = org.department1.xiaohong;
  var xiaowang = org.department2.xiaowang;
  var xiaoli = org.department2.xiaoli;
  ```

- 新方法 : 闭包对变量的私有化

  ```
  var init = (function () {
    var name = 'lpj',
        age = '20';
    function sayName() {
      console.log(name);
    }
    function sayAge() {
      console.log(age);
    }
    return function () {
      sayName();
      sayAge();
    };
  } ())
  ```

------------------------------------------------------

## 思考问题

- 模仿Jquery 实现链式调用模式

  ```
  var obj = {
    eat : function () {
      console.log('eat');
      return this;
    },
    drink : function () {
      console.log('drink');
      return this;
    },
    sleep : function () {
      console.log('sleep');
      return this;
    }
  }

  obj.eat().drink().sleep()
  ```

------------------------------------------------------

## 属性的表示方法

- ```obj.prop```

- ```obj["prop"]```

  ```
  var person = {
    wife1: { name: 'wang' },
    wife2: { name: 'zhao' },
    wife3: { name: 'li' },
    sayWife: function(num) {
      console.log(this['wife' + num]);
    }
  }
  person.sayWife(1);
  person.sayWife(2);
  person.sayWife(3);
  ```

- Tips : ```obj.prop``` 会在底层被转换为 ```obj["prop"]```

  - 故推荐使用 ```obj["prop"]``` 的方式省去底层转化的步骤 , 起到优化代码的作用

------------------------------------

## 对象的遍历/枚举 ( enumeration )

- for in

  ```
  var obj = {
    name : 'xiaoming',
    age : 20,
    sex : 'male',
    key : 'error'
  }
  for (var key in obj) {
    console.log(typeof(key), key, obj[key]);
  }
  for (var key in obj) {
    console.log(obj.key); // 被转化为obj['key'] , 故打印四遍error
  }

  var arr = ['a', 'b', 'c'];
  for (var index in arr) {
    console.log(index, arr[index]);
  }
  ```

    - Tips : for in 会遍历整条原型链上所有自己设置的属性 , 忽略所有系统自带的属性

      ```
      var arr = [];
      arr.key1 = 'hu';
      arr.__proto__.key2 = 'ha';
      Object.prototype.key3 = 'hei';
      for (var key in arr) {
        console.log(arr[key]);
      }
      ```

- hasOwnProperty()

  - return true : 该属性为对象本身的属性 , 而非从原型链继承的

  - return false : 该属性是从原型链继承的 , 而非对象本身的属性

    ```
    var obj = {
      name : 'xiaoliu',
      __proto__ : {
        lastName : 'liu'
      }
    }
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        console.log(obj[key]);
      }
    }
    ```

- in 判断是否能在对象本身及其整条原型链上找到该属性

  ```
  var arr = [];
  arr.name = 'haha';
  console.log('name' in arr); // true, 'name' in arr
  console.log('slice' in arr); // true, 'slice' in arr.__proto__
  console.log('valueOf' in arr); // true, 'valueOf' in Object.prototype
  ```

- A instanceof B 判断对象A的原型链上有没有构造函数B的原型

  ```
  function Person() {}
  var p = new Person();
  console.log(p instanceof Person); // true
  console.log(p instanceof Object); // true
  
  var arr = [];
  console.log(arr instanceof Array); // true
  console.log(arr instanceof Object); // true
  ```

-------------------------------------------

## 思考问题

- 给定变量temp , 该变量为 {} 或 [] , 如何判断其究竟是 {} 还是 []

  ```
  // 方案一 : constructor
  temp.constructor == function Object() { [native code] } // temp 为 {}
  temp.constructor == function Array() { [native code] } // temp 为 []
  ```

  ```
  // 方案二 : instanceof
  temp instanceof Array // true则temp为[], 否则temp为{}
  ```

  ```
  // 方案三 : call
  Object.prototype.toString.call({}) // "[object Object]"
  Object.prototype.toString.call([]) // "[object Array]"
  ```

  - Tips : 方案三是万无一失的 , 而方案一二在父子域跨域的情况下会出错

---------------------------------------------

## 小知识点

console.log(null > 0, null < 0, null == 0);
console.log(undefined > 0, undefined < 0, undefined == 0);
console.log(null == undefined);
console.log(null === undefined);
console.log(NaN == NaN);
console.log(NaN === NaN);